import re

class Rule:

    def __init__(self, pattern_str, response_str, response_func):
        self.pattern_str = pattern_str
        self.response_str = response_str
	self.response_func = response_func



    def does_match_rule(self, input_str):
        # Here the program should look at input_str and return true if it
        # matches the rule's pattern. Otherwise return false.
        var = re.match(self.pattern_str, input_str)
        if var:
            return True
        return False


    def generate_response(self, input_str):
        # Here the program should accept input_str as input and attempt to
        # match it with the pattern. It then returns the response as 
        # generated by the response pattern. If input_str does not fit the
        # pattern, return nil.

	# Execute the optional response function.
	if self.response_func != None:
		self.response_func(input_str)

        t = re.match(self.pattern_str, input_str)

	response_list = self.response_str.split()

	#print "\n"
	#print response_list
	#print "\n"

	for i,x in enumerate(response_list):
		if x[0] == '?':
			response_list[i] = t.group(x.split("?")[1])

	#print "\n"
	#print response_list
	#print "\n"

        return ' '.join(response_list)

        # var_pairs = get_var_pairs(self.pattern_str, input_str)
        # response_str = splice_variable_pairs(self.response_str, var_pairs)
        # return response_str



    # def get_var_pairs(self, pattern, input_str):
    #     # Take in an input_str, return a list of pairs containing the name
    #     # of a pattern matched variable and the variable itself, respectively.
    #     # If this cannot be done, return nil.




    # def splice_var_pairs(self, response, var_pairs):
    #     # Take a response pattern and splice the appropriate variable pairs
    #     # from var_pairs into response. If the operation cannot be completed,
    #     # return nil. We might want to do this with string.substitute.
